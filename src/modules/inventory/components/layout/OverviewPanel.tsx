import { useEffect, useState, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import { useSelector, useDispatch } from 'react-redux';
import {
  setLayout,
  setCategoryOrder,
  setSettings,
} from '@/modules/inventory/store/inventorySlice';
import CategoryCard from '@/modules/inventory/components/ui/card/CategoryCard';
import { generateLayoutByType } from '@/shared/utils/layout/layoutAutoGenerated';
import { inventoryApi } from '@/modules/inventory/api';
import ChangeLayoutButton from '@/modules/inventory/components/ui/other/ChangeLayoutButton';
import {
  selectCurrentLayout,
  selectCategoryOrder,
} from '@/modules/inventory/store/inventorySlice';
import {
  selectAllGroups,
  fetchGroups,
} from '@/modules/groups/store/groupsSlice';
import {
  selectActiveRefrigeratorId,
} from '@/store/slices/refrigeratorSlice';
import useFadeInAnimation from '@/shared/hooks/useFadeInAnimation';
import type { CategoryInfo } from '@/modules/inventory/types';
import { categories as defaultCategories } from '@/modules/inventory/constants/categories';
import { getRefrigeratorId } from '@/modules/inventory/utils/getRefrigeratorId';

const DynamicGridAreaStyles = ({
  categories,
}: {
  categories: CategoryInfo[];
}) => {
  const css = categories
    .map((c) => `.grid-area-${c.id}{grid-area:${c.id};}`)
    .join('\n');

  return <style>{css}</style>;
};

const OverviewPanel: React.FC = () => {
  const [categories, setCategories] = useState<CategoryInfo[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { ref: contentRef } = useFadeInAnimation<HTMLElement>({ isLoading });
  const currentLayout = useSelector(selectCurrentLayout);
  const categoryOrder = useSelector(selectCategoryOrder);
  const dispatch = useDispatch();
  const { groupId } = useParams<{ groupId: string }>();
  
  // Get active ID from Redux
  const activeRefrigeratorId = useSelector(selectActiveRefrigeratorId);

  // Get groups to derive default ID
  const groups = useSelector(selectAllGroups);
  const firstGroupId = groups[0]?.id;

  // Effect 1: 確保 groups 已載入
  useEffect(() => {
    if (groups.length === 0) {
      // @ts-ignore
      dispatch(fetchGroups());
    }
  }, [dispatch, groups.length]);

  // Effect 2: 當 groups 已載入時，載入 settings
  useEffect(() => {
    // 計算 refrigeratorId: 優先使用 Redux active ID，其次 URL groupId，最後 fallback
    const refId = activeRefrigeratorId || getRefrigeratorId(groupId, groups);

    // 如果還沒有 refId，不執行
    if (!refId) {
      if (groups.length > 0) {
        console.error('[Overview] 無法取得 refrigeratorId');
        setIsLoading(false);
      }
      return;
    }

    const fetchData = async () => {
      try {
        setIsLoading(true);

        // 載入設定
        const settingsResponse = await inventoryApi.getSettings(refId);
        const settings = settingsResponse.data.settings;

        // 更新設定到 Redux
        dispatch(setSettings(settings));

        // 如果設定中有 layoutType，更新 layout
        if (settings.layoutType) {
          dispatch(setLayout(settings.layoutType));
        }

        // 建立預設類別對照表
        const defaultCategoryMap = new Map(
          defaultCategories.map((c) => [c.id, c]),
        );

        // 取得實際庫存項目來計算各類別數量
        let categoryCounts: Record<string, number> = {};
        try {
          const inventoryResponse = await inventoryApi.getInventory({
            groupId: refId,
          });
          const items = inventoryResponse.data.items || [];

          // 計算每個類別的數量
          items.forEach((item) => {
            const cat = item.category;
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
          });
        } catch (inventoryError) {
          console.warn(
            '[Overview] 無法取得庫存數量，使用預設值 0',
            inventoryError,
          );
        }

        // 優先使用 settings 內的 categories，若無則 fallback 到 categories API
        let categoryData: CategoryInfo[] = [];

        if (settings.categories && settings.categories.length > 0) {
          // 從 settings.categories 轉換為 CategoryInfo 格式
          // 使用預設類別常數補充樣式資訊
          categoryData = settings.categories.map((cat) => {
            const defaults = defaultCategoryMap.get(cat.id);
            return {
              id: cat.id,
              title: cat.title,
              count: categoryCounts[cat.id] || 0, // 使用實際數量
              imageUrl: defaults?.img || '',
              bgColor: defaults?.bgColor || '',
              slogan: defaults?.slogan || '',
              description: cat.subCategories || defaults?.description || [],
            };
          });
        } else {
          // Fallback 到 categories API
          const categoriesResponse = await inventoryApi.getCategories(refId);
          categoryData = categoriesResponse.data.categories.map((cat) => ({
            ...cat,
            count: categoryCounts[cat.id] || cat.count || 0,
          }));
        }

        // 如果設定中有 categoryOrder，更新順序
        if (settings.categoryOrder) {
          dispatch(setCategoryOrder(settings.categoryOrder));
        } else {
          // 如果沒有設定順序，使用類別資料的預設順序
          const defaultOrder = categoryData.map((c) => c.id);
          dispatch(setCategoryOrder(defaultOrder));
        }

        // 設定類別資料
        setCategories(categoryData);
      } catch (error) {
        console.error('Failed to fetch data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [groupId, firstGroupId, dispatch, activeRefrigeratorId, groups]);

  // 根據 Redux 的 categoryOrder 排序類別（這會在 categoryOrder 變化時自動更新）
  const sortedCategories = useMemo(() => {
    if (categories.length === 0) {
      return [];
    }

    if (!categoryOrder || categoryOrder.length === 0) {
      return categories;
    }

    const ordered: CategoryInfo[] = [];

    // 按照 categoryOrder 順序添加類別
    categoryOrder.forEach((id) => {
      const category = categories.find((c) => c.id === id);
      if (category) {
        ordered.push(category);
      }
    });

    // 添加不在 categoryOrder 中的類別（如果有新類別）
    categories.forEach((category) => {
      if (!categoryOrder.includes(category.id)) {
        ordered.push(category);
      }
    });

    return ordered;
  }, [categories, categoryOrder]);

  // 使用原始版面佈局（保持不變）
  const layout = generateLayoutByType(currentLayout);
  const gridTemplate = layout.map((row) => `"${row.join(' ')}"`).join(' ');

  // 從版面中提取格子順序（不重複的類別 ID）
  const layoutSlots = useMemo(() => {
    const slots: string[] = [];
    layout.forEach((row) => {
      row.forEach((cell) => {
        if (cell && !slots.includes(cell)) {
          slots.push(cell);
        }
      });
    });
    return slots;
  }, [layout]);

  // 建立「版面格子 ID → 實際顯示的類別」的映射
  // 例如：layout 格子 0 對應 sortedCategories[0]
  const slotToCategoryMap = useMemo(() => {
    const map: Record<string, CategoryInfo | undefined> = {};
    layoutSlots.forEach((slotId, index) => {
      // 將第 index 個格子對應到排序後的第 index 個類別
      map[slotId] = sortedCategories[index];
    });
    return map;
  }, [layoutSlots, sortedCategories]);

  if (isLoading) {
    return (
      <div className="p-4 text-center text-neutral-400">
        Loading categories...
      </div>
    );
  }

  return (
    <section ref={contentRef} className="pb-30 relative">
      <DynamicGridAreaStyles categories={categories} />

      <div
        className="max-w-layout-container mx-auto grid gap-3 mb-6"
        style={{
          gridTemplateAreas: gridTemplate,
          gridTemplateColumns: '1fr 1fr',
          gridAutoRows: '9rem',
        }}
      >
        {/* 按照版面格子順序渲染，但顯示排序後的類別內容 */}
        {layoutSlots.map((slotId) => {
          const category = slotToCategoryMap[slotId];
          if (!category) return null;

          return (
            <div key={slotId} className={`grid-area-${slotId}`}>
              <CategoryCard
                id={category.id}
                title={`${category.title} | ${category.count}`}
                img={category.imageUrl}
                bgColor={category.bgColor}
                boxShadow="shadow-[0_6px_14px_-2px_rgba(0,0,0,0.06)]"
              />
            </div>
          );
        })}
      </div>

      <ChangeLayoutButton />
    </section>
  );
};

export default OverviewPanel;
