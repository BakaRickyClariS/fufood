name: Auto PR by Branch Naming

on:
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  create-pull-requests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Fetch all branches
        run: git fetch origin
      - name: Create Pull Requests
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_PAT }}
          script: |
            const { execSync } = require('child_process');
            const unmergedBranches = execSync('git branch -r --no-merged origin/dev | grep -v origin/dev | grep -v origin/main | grep -v origin/qa | sed "s|origin/||"')
              .toString()
              .trim()
              .split('\n')
              .map(b => b.trim())
              .filter(b => b);
            for (const branch of unmergedBranches) {
              let labels = [];
              if (branch.startsWith('Feature-')) labels = ['feature', 'enhancement'];
              else if (branch.startsWith('Fix-')) labels = ['bug', 'fix'];
              else if (branch.startsWith('Update-')) labels = ['documentation', 'update'];
              else if (branch.startsWith('Hotfix-')) labels = ['hotfix', 'urgent'];
              // FETCH remote branch and update refs to avoid ambiguous argument error
              execSync(`git fetch origin ${branch}:${branch}`);
              const commits = execSync(`git log origin/dev..${branch} --pretty=format:"- %s" --reverse`)
                .toString()
                .trim();
              const prBody = `## Commits\n\n${commits || 'No commit messages available'}`;
              for (const base of ['dev']) {
                try {
                  const pr = await github.rest.pulls.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    head: branch,
                    base: base,
                    title: `${branch}`,
                    body: prBody
                  });
                  if (labels.length > 0) {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.data.number,
                      labels: labels
                    });
                  }
                } catch (e) {
                  console.log(`Skipped ${base} PR for ${branch}: ${e.message}`);
                }
              }
            }
