name: Create Release Branch

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release-branch:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.next }}
      release_branch: ${{ steps.create_branch.outputs.branch_name }}
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ACTIONS_PAT }}
          ref: dev
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # æ­¥é©Ÿ 1: æƒææ‰€æœ‰ dev-vXXX åˆ†æ”¯ï¼Œæ¨æ•²æœ€æ–°ç‰ˆæœ¬è™Ÿ
      - name: Detect latest version from existing branches
        id: version
        run: |
          # Fetch all remote branches
          git fetch origin --all 2>&1 | grep -E "(remote|branch)" | head -5

          echo "ğŸ“‹ Scanning existing dev-v* branches..."
          git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V | tail -5
          echo ""

          # æƒææ‰€æœ‰ dev-vXXX åˆ†æ”¯ï¼Œæå–ç‰ˆæœ¬è™Ÿ
          LATEST_VERSION="0.0.0"
          LATEST_BRANCH=""

          # åˆ—å‡ºæ‰€æœ‰ dev-v é–‹é ­çš„åˆ†æ”¯ï¼ˆæŒ‰ç‰ˆæœ¬æ’åºï¼‰
          for branch in $(git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V); do
            # æå–ç‰ˆæœ¬è™Ÿéƒ¨åˆ†: origin/dev-v020 â†’ 020
            VERSION_NUM=$(echo "$branch" | sed 's/^origin\/dev-v//')
            
            # æª¢æŸ¥ç‰ˆæœ¬è™Ÿæ˜¯å¦æœ‰æ•ˆï¼ˆåªåŒ…å«æ•¸å­—ï¼‰
            if [[ $VERSION_NUM =~ ^[0-9]+$ ]]; then
              # è½‰æ›: 020 â†’ 0.2.0, 001 â†’ 0.0.1, 100 â†’ 1.0.0
              NUM_LEN=${#VERSION_NUM}
              
              if [ $NUM_LEN -eq 1 ]; then
                MAJOR=0
                MINOR=0
                PATCH=$VERSION_NUM
              elif [ $NUM_LEN -eq 2 ]; then
                MAJOR=0
                MINOR=${VERSION_NUM:0:1}
                PATCH=${VERSION_NUM:1:1}
              elif [ $NUM_LEN -eq 3 ]; then
                MAJOR=${VERSION_NUM:0:1}
                MINOR=${VERSION_NUM:1:1}
                PATCH=${VERSION_NUM:2:1}
              else
                MAJOR=${VERSION_NUM:0:1}
                MINOR=${VERSION_NUM:1:1}
                PATCH=${VERSION_NUM:2:1}
              fi
              
              DETECTED_VERSION="$MAJOR.$MINOR.$PATCH"
              
              # æ¯”è¼ƒç‰ˆæœ¬ï¼ˆç°¡å–®çš„æ•¸å€¼æ¯”è¼ƒï¼‰
              LATEST_MAJOR=$(echo $LATEST_VERSION | cut -d. -f1)
              LATEST_MINOR=$(echo $LATEST_VERSION | cut -d. -f2)
              LATEST_PATCH=$(echo $LATEST_VERSION | cut -d. -f3)
              
              if [ $MAJOR -gt $LATEST_MAJOR ] || \
                 ([ $MAJOR -eq $LATEST_MAJOR ] && [ $MINOR -gt $LATEST_MINOR ]) || \
                 ([ $MAJOR -eq $LATEST_MAJOR ] && [ $MINOR -eq $LATEST_MINOR ] && [ $PATCH -gt $LATEST_PATCH ]); then
                LATEST_VERSION=$DETECTED_VERSION
                LATEST_BRANCH=$branch
              fi
            fi
          done

          echo "ğŸ¯ Latest version detected: v$LATEST_VERSION (from $LATEST_BRANCH)"
          echo "current=$LATEST_VERSION" >> $GITHUB_OUTPUT

          # è¨ˆç®—åˆå§‹æ–°ç‰ˆæœ¬
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
          case "${{ github.event.inputs.version_type }}" in
            major)
              NEW_VERSION="$((MAJOR+1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR+1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              ;;
          esac

          echo "next=$NEW_VERSION" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 2: æª¢æŸ¥è¨ˆç®—çš„ç‰ˆæœ¬åˆ†æ”¯æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨å‰‡è‡ªå‹•é€²ä½
      - name: Check and auto-increment version if conflict
        id: check_version
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
        run: |
          CURRENT_VERSION=$INITIAL_VERSION
          ATTEMPT=0
          MAX_ATTEMPTS=10

          echo "ğŸ” Checking if branch dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') exists..."

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            BRANCH_SUFFIX=$(echo "$CURRENT_VERSION" | sed 's/\.//g')
            BRANCH_NAME="dev-v${BRANCH_SUFFIX}"
            
            # æª¢æŸ¥åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            if ! git rev-parse --verify "origin/$BRANCH_NAME" >/dev/null 2>&1; then
              echo "âœ… Branch $BRANCH_NAME is available!"
              echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
              break
            else
              echo "âš ï¸ Branch $BRANCH_NAME already exists, auto-incrementing..."
              
              # é€²ä½ patch ç‰ˆæœ¬
              IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
              CURRENT_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              
              ATTEMPT=$((ATTEMPT+1))
            fi
          done

          if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
            echo "âŒ ERROR: Could not find an available version after $MAX_ATTEMPTS attempts!"
            exit 1
          fi

          if [ "$CURRENT_VERSION" != "$INITIAL_VERSION" ]; then
            echo ""
            echo "ğŸ”„ Version auto-incremented:"
            echo "   Initial: v$INITIAL_VERSION â†’ dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') (already exists)"
            echo "   Final:   v$CURRENT_VERSION â†’ dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') (using this)"
          fi

      # æ­¥é©Ÿ 3: æ›´æ–°ç‰ˆæœ¬åœ¨ package.json
      - name: Update version in package.json
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          if [ -f package.json ]; then
            node -e "const pkg = require('./package.json'); pkg.version = '$NEW_VERSION'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
            echo "âœ… Updated package.json to v$NEW_VERSION"
          else
            echo "âš ï¸ package.json not found"
          fi

      # æ­¥é©Ÿ 4: æ›´æ–° CHANGELOG
      - name: Update CHANGELOG
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          TODAY=$(date +%Y-%m-%d)
          cat > /tmp/new_entry.txt << EOF
          ## [$NEW_VERSION] - $TODAY

          ### Added
          - New features

          ### Fixed
          - Bug fixes

          ### Changed
          - Changes

          EOF

          if [ -f CHANGELOG.md ]; then
            cat /tmp/new_entry.txt CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
            echo "âœ… Updated CHANGELOG.md"
          else
            cat /tmp/new_entry.txt > CHANGELOG.md
            echo "âœ… Created CHANGELOG.md"
          fi

      # æ­¥é©Ÿ 5: å»ºç«‹å¸¶ç‰ˆæœ¬è™Ÿçš„åˆ†æ”¯
      - name: Create release branch
        id: create_branch
        env:
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          echo "ğŸŒ¿ Creating branch: $BRANCH_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # å»ºç«‹æ–°åˆ†æ”¯
          git checkout -b "$BRANCH_NAME"
          echo "âœ… Created local branch: $BRANCH_NAME"

          # åª add å­˜åœ¨çš„æª”æ¡ˆ
          git add package.json 2>/dev/null || true
          git add CHANGELOG.md 2>/dev/null || true

          # æª¢æŸ¥æ˜¯å¦æœ‰æª”æ¡ˆè¢« stage
          if git diff --cached --quiet; then
            echo "âš ï¸ No changes to commit, creating empty commit"
            git commit --allow-empty -m "chore(release): v$NEW_VERSION"
          else
            echo "âœ… Committing changes..."
            git commit -m "chore(release): v$NEW_VERSION"
          fi

          # Push åˆ°é ç«¯
          echo "Pushing to remote..."
          if git push -u origin "$BRANCH_NAME" 2>&1; then
            echo "âœ… Successfully pushed to origin/$BRANCH_NAME"
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to push"
            exit 1
          fi

      # æ­¥é©Ÿ 6: å–å¾—å·² merge åˆ° dev çš„æ‰€æœ‰å‰¯åˆ†æ”¯
      - name: Get all merged feature branches
        id: branches_list
        run: |
          BRANCHES=""

          # ç²å–æ‰€æœ‰é ç«¯åˆ†æ”¯
          for branch in $(git branch -r --format='%(refname:short)' | grep '^origin/' | grep -v '^origin/HEAD' | grep -v '^origin/main$' | grep -v '^origin/dev$' | grep -v '^origin/qa$' | grep -v '^origin/dev-v'); do
            CLEAN_BRANCH=$(echo "$branch" | sed 's/^origin\///')
            
            if [[ "$CLEAN_BRANCH" =~ ^(Feature|Fix|Update|Hotfix)- ]]; then
              # æª¢æŸ¥é€™å€‹åˆ†æ”¯æ˜¯å¦å·²ç¶“ merge é€² dev
              if git merge-base --is-ancestor "$branch" origin/dev 2>/dev/null; then
                BRANCHES="$BRANCHES- $CLEAN_BRANCH"$'\n'
              fi
            fi
          done

          # å¦‚æœæ²’æœ‰å‰¯åˆ†æ”¯ï¼Œå°±åˆ—å‡ºä¸»è¦åˆ†æ”¯
          if [ -z "$BRANCHES" ]; then
            BRANCHES="- dev"$'\n'"- qa"
          else
            # ç§»é™¤æœ«å°¾çš„æ–°è¡Œ
            BRANCHES=$(echo "$BRANCHES" | sed '$ s/.$//')
          fi

          echo "branches<<EOF" >> $GITHUB_OUTPUT
          echo "$BRANCHES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 7: ç”¢ç”Ÿ PR æè¿°
      - name: Generate PR description
        id: pr_body
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
          BRANCHES: ${{ steps.branches_list.outputs.branches }}
        run: |
          VERSION_NUM=$(echo "$NEW_VERSION" | sed 's/\.//g')
          cat > /tmp/pr_body.txt << 'EOF'
          Dev v$VERSION_NUM merge:

          $BRANCHES
          EOF

          BODY=$(cat /tmp/pr_body.txt)
          BODY="${BODY//\$VERSION_NUM/$VERSION_NUM}"
          BODY="${BODY//\$BRANCHES/$BRANCHES}"

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 8: å»ºç«‹ Release PR
      - name: Create Release PR to main
        id: create_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.ACTIONS_PAT }}
          commit-message: 'chore(release): v${{ steps.check_version.outputs.final_version }}'
          title: 'Dev v${{ steps.check_version.outputs.final_version }}'
          body: ${{ steps.pr_body.outputs.body }}
          branch: ${{ steps.check_version.outputs.branch_name }}
          base: main
          labels: 'release,automation'
          assignees: ${{ github.actor }}
          draft: false
          delete-branch: false

      - name: Notify workflow completion
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
          FINAL_VERSION: ${{ steps.check_version.outputs.final_version }}
          OLD_VERSION: ${{ steps.version.outputs.current }}
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Release workflow completed successfully!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Version Information:"
          echo "   Previous version:  v$OLD_VERSION"
          echo "   Calculated version: v$INITIAL_VERSION"

          if [ "$INITIAL_VERSION" != "$FINAL_VERSION" ]; then
            echo "   âš ï¸  Conflict detected! Branch dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') already exists"
            echo "   ğŸ”„ Auto-incremented to: v$FINAL_VERSION"
          else
            echo "   Final version:     v$FINAL_VERSION"
          fi

          echo ""
          echo "ğŸ“Œ Branch & PR Details:"
          echo "   Branch name: $BRANCH_NAME"
          echo "   PR number:   #$PR_NUMBER"
          echo "   Base branch: main"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
