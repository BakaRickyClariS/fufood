name: Create Release Branch

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release-branch:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.next }}
      release_branch: ${{ steps.create_branch.outputs.branch_name }}
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ACTIONS_PAT }}
          ref: dev
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # æ­¥é©Ÿ 1: æƒææ‰€æœ‰ä¾†æºï¼ˆåˆ†æ”¯ + å·²åˆä½µ PRï¼‰ä¾†åµæ¸¬æœ€æ–°ç‰ˆæœ¬è™Ÿ
      - name: Detect latest version from branches and merged PRs
        id: version
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
        run: |
          # Fetch all remote branches with prune to remove stale references
          git fetch origin --all --prune 2>&1 | head -10

          echo "ğŸ“‹ Scanning existing dev-v* branches..."
          git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V | tail -5 || echo "No dev-v branches found"
          echo ""

          echo "ğŸ“‹ Scanning merged PRs to main for version history..."
          # ä½¿ç”¨ gh CLI å–å¾—å·²åˆä½µåˆ° main çš„ PR æ¨™é¡Œ
          MERGED_VERSIONS=$(gh pr list --state merged --base main --limit 50 --json title --jq '.[].title' 2>/dev/null | grep -oP 'Dev v\K[0-9]+' | sort -V | tail -5 || echo "")
          echo "Found merged versions: $MERGED_VERSIONS"
          echo ""

          # æƒææ‰€æœ‰ dev-vXXX åˆ†æ”¯ï¼Œæå–ç‰ˆæœ¬è™Ÿ
          LATEST_VERSION="0.0.0"
          LATEST_SOURCE="initial"

          # å‡½æ•¸ï¼šå°‡ç‰ˆæœ¬è™Ÿå­—ä¸²è½‰æ›ç‚º X.Y.Z æ ¼å¼
          parse_version() {
            local VERSION_NUM=$1
            local NUM_LEN=${#VERSION_NUM}
            local MAJOR=0 MINOR=0 PATCH=0
            
            if [ $NUM_LEN -eq 1 ]; then
              PATCH=$VERSION_NUM
            elif [ $NUM_LEN -eq 2 ]; then
              MINOR=${VERSION_NUM:0:1}
              PATCH=${VERSION_NUM:1:1}
            elif [ $NUM_LEN -ge 3 ]; then
              # è™•ç† 3 ä½æ•¸ä»¥ä¸Šï¼šå–å‰ä¸‰ä½
              MAJOR=${VERSION_NUM:0:1}
              MINOR=${VERSION_NUM:1:1}
              PATCH=${VERSION_NUM:2:1}
            fi
            echo "$MAJOR.$MINOR.$PATCH"
          }

          # å‡½æ•¸ï¼šæ¯”è¼ƒå…©å€‹ç‰ˆæœ¬ï¼Œå›å‚³ 1 å¦‚æœ $1 > $2
          version_gt() {
            local V1_MAJOR=$(echo $1 | cut -d. -f1)
            local V1_MINOR=$(echo $1 | cut -d. -f2)
            local V1_PATCH=$(echo $1 | cut -d. -f3)
            local V2_MAJOR=$(echo $2 | cut -d. -f1)
            local V2_MINOR=$(echo $2 | cut -d. -f2)
            local V2_PATCH=$(echo $2 | cut -d. -f3)
            
            if [ $V1_MAJOR -gt $V2_MAJOR ]; then return 0; fi
            if [ $V1_MAJOR -eq $V2_MAJOR ] && [ $V1_MINOR -gt $V2_MINOR ]; then return 0; fi
            if [ $V1_MAJOR -eq $V2_MAJOR ] && [ $V1_MINOR -eq $V2_MINOR ] && [ $V1_PATCH -gt $V2_PATCH ]; then return 0; fi
            return 1
          }

          # ä¾†æº 1: æƒæç¾æœ‰çš„é ç«¯åˆ†æ”¯
          echo "ğŸ” Source 1: Scanning remote branches..."
          for branch in $(git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V 2>/dev/null || echo ""); do
            VERSION_NUM=$(echo "$branch" | sed 's/^origin\/dev-v//')
            if [[ $VERSION_NUM =~ ^[0-9]+$ ]]; then
              DETECTED=$(parse_version $VERSION_NUM)
              if version_gt "$DETECTED" "$LATEST_VERSION"; then
                LATEST_VERSION=$DETECTED
                LATEST_SOURCE="branch: $branch"
              fi
            fi
          done

          # ä¾†æº 2: æƒæå·²åˆä½µåˆ° main çš„ PR æ¨™é¡Œï¼ˆæŠ“å–æ­·å²ç‰ˆæœ¬ï¼‰
          echo "ğŸ” Source 2: Scanning merged PR titles..."
          for VERSION_NUM in $(gh pr list --state merged --base main --limit 100 --json title --jq '.[].title' 2>/dev/null | grep -oP 'Dev v\K[0-9]+' || echo ""); do
            if [[ $VERSION_NUM =~ ^[0-9]+$ ]]; then
              DETECTED=$(parse_version $VERSION_NUM)
              if version_gt "$DETECTED" "$LATEST_VERSION"; then
                LATEST_VERSION=$DETECTED
                LATEST_SOURCE="merged PR: Dev v$VERSION_NUM"
              fi
            fi
          done

          # ä¾†æº 3: æƒæ package.json ä¸­çš„ç‰ˆæœ¬ï¼ˆä½œç‚ºå‚™ç”¨ï¼‰
          echo "ğŸ” Source 3: Checking package.json..."
          if [ -f package.json ]; then
            PKG_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
            if version_gt "$PKG_VERSION" "$LATEST_VERSION"; then
              LATEST_VERSION=$PKG_VERSION
              LATEST_SOURCE="package.json"
            fi
          fi

          echo ""
          echo "ğŸ¯ Latest version detected: v$LATEST_VERSION (from $LATEST_SOURCE)"
          echo "current=$LATEST_VERSION" >> $GITHUB_OUTPUT

          # è¨ˆç®—åˆå§‹æ–°ç‰ˆæœ¬
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
          case "${{ github.event.inputs.version_type }}" in
            major)
              NEW_VERSION="$((MAJOR+1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR+1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              ;;
          esac

          echo "next=$NEW_VERSION" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 2: æª¢æŸ¥è¨ˆç®—çš„ç‰ˆæœ¬åˆ†æ”¯æ˜¯å¦å­˜åœ¨ï¼ˆå¤šé‡ä¾†æºé©—è­‰ï¼‰ï¼Œå¦‚æœå­˜åœ¨å‰‡è‡ªå‹•é€²ä½
      - name: Check and auto-increment version if conflict
        id: check_version
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
        run: |
          CURRENT_VERSION=$INITIAL_VERSION
          ATTEMPT=0
          MAX_ATTEMPTS=10

          echo "ğŸ” Checking if branch dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') exists..."

          # å‡½æ•¸ï¼šæª¢æŸ¥åˆ†æ”¯æˆ–ç›¸é—œ PR æ˜¯å¦å·²å­˜åœ¨
          branch_or_pr_exists() {
            local BRANCH_NAME=$1
            local VERSION_NUM=$(echo "$BRANCH_NAME" | sed 's/dev-v//')
            
            # æª¢æŸ¥ 1: é ç«¯åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            if git ls-remote --heads origin "$BRANCH_NAME" 2>/dev/null | grep -q "$BRANCH_NAME"; then
              echo "remote-branch"
              return 0
            fi
            
            # æª¢æŸ¥ 2: æ˜¯å¦æœ‰ open çš„ PR ä½¿ç”¨é€™å€‹ç‰ˆæœ¬
            # ä½¿ç”¨ || true ç¢ºä¿ gh æŒ‡ä»¤å¤±æ•—æ™‚ä¸æœƒä¸­æ–·è…³æœ¬
            OPEN_PRS=$(gh pr list --state open --json title --jq '.[].title' 2>/dev/null || echo "")
            if echo "$OPEN_PRS" | grep -q "Dev v$VERSION_NUM" 2>/dev/null; then
              echo "open-pr"
              return 0
            fi
            
            # æª¢æŸ¥ 3: æ˜¯å¦æœ‰å·²åˆä½µçš„ PR ä½¿ç”¨é€™å€‹ç‰ˆæœ¬
            MERGED_PRS=$(gh pr list --state merged --base main --limit 100 --json title --jq '.[].title' 2>/dev/null || echo "")
            if echo "$MERGED_PRS" | grep -q "Dev v$VERSION_NUM" 2>/dev/null; then
              echo "merged-pr"
              return 0
            fi
            
            echo "not-found"
            return 0
          }

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            BRANCH_SUFFIX=$(echo "$CURRENT_VERSION" | sed 's/\.//g')
            BRANCH_NAME="dev-v${BRANCH_SUFFIX}"
            
            # å¤šé‡ä¾†æºæª¢æŸ¥
            EXISTENCE_CHECK=$(branch_or_pr_exists "$BRANCH_NAME")
            
            if [ "$EXISTENCE_CHECK" = "not-found" ]; then
              echo "âœ… Branch $BRANCH_NAME is available (no conflicts found)!"
              echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
              break
            else
              echo "âš ï¸ Conflict detected for $BRANCH_NAME (source: $EXISTENCE_CHECK), auto-incrementing..."
              
              # é€²ä½ patch ç‰ˆæœ¬
              IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
              CURRENT_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              
              ATTEMPT=$((ATTEMPT+1))
            fi
          done

          if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
            echo "âŒ ERROR: Could not find an available version after $MAX_ATTEMPTS attempts!"
            exit 1
          fi

          if [ "$CURRENT_VERSION" != "$INITIAL_VERSION" ]; then
            echo ""
            echo "ğŸ”„ Version auto-incremented:"
            echo "   Initial: v$INITIAL_VERSION â†’ dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') (conflict)"
            echo "   Final:   v$CURRENT_VERSION â†’ dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') (using this)"
          fi

      # æ­¥é©Ÿ 3: æ›´æ–°ç‰ˆæœ¬åœ¨ package.json
      - name: Update version in package.json
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          if [ -f package.json ]; then
            node -e "const pkg = require('./package.json'); pkg.version = '$NEW_VERSION'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
            echo "âœ… Updated package.json to v$NEW_VERSION"
          else
            echo "âš ï¸ package.json not found"
          fi

      # æ­¥é©Ÿ 4: æ›´æ–° CHANGELOG
      - name: Update CHANGELOG
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          TODAY=$(date +%Y-%m-%d)
          cat > /tmp/new_entry.txt << EOF
          ## [$NEW_VERSION] - $TODAY

          ### Added
          - New features

          ### Fixed
          - Bug fixes

          ### Changed
          - Changes

          EOF

          if [ -f CHANGELOG.md ]; then
            cat /tmp/new_entry.txt CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
            echo "âœ… Updated CHANGELOG.md"
          else
            cat /tmp/new_entry.txt > CHANGELOG.md
            echo "âœ… Created CHANGELOG.md"
          fi

      # æ­¥é©Ÿ 5: å»ºç«‹å¸¶ç‰ˆæœ¬è™Ÿçš„åˆ†æ”¯
      - name: Create release branch
        id: create_branch
        env:
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          echo "ğŸŒ¿ Creating branch: $BRANCH_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # å»ºç«‹æ–°åˆ†æ”¯
          git checkout -b "$BRANCH_NAME"
          echo "âœ… Created local branch: $BRANCH_NAME"

          # åª add å­˜åœ¨çš„æª”æ¡ˆ
          git add package.json 2>/dev/null || true
          git add CHANGELOG.md 2>/dev/null || true

          # æª¢æŸ¥æ˜¯å¦æœ‰æª”æ¡ˆè¢« stage
          if git diff --cached --quiet; then
            echo "âš ï¸ No changes to commit, creating empty commit"
            git commit --allow-empty -m "chore(release): v$NEW_VERSION"
          else
            echo "âœ… Committing changes..."
            git commit -m "chore(release): v$NEW_VERSION"
          fi

          # Push åˆ°é ç«¯
          echo "Pushing to remote..."
          if git push -u origin "$BRANCH_NAME" 2>&1; then
            echo "âœ… Successfully pushed to origin/$BRANCH_NAME"
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to push"
            exit 1
          fi

      # æ­¥é©Ÿ 6: å–å¾—å·² merge åˆ° dev çš„æ‰€æœ‰å‰¯åˆ†æ”¯
      - name: Get all merged feature branches
        id: branches_list
        run: |
          BRANCHES=""

          # ç²å–æ‰€æœ‰é ç«¯åˆ†æ”¯
          for branch in $(git branch -r --format='%(refname:short)' | grep '^origin/' | grep -v '^origin/HEAD' | grep -v '^origin/main$' | grep -v '^origin/dev$' | grep -v '^origin/qa$' | grep -v '^origin/dev-v'); do
            CLEAN_BRANCH=$(echo "$branch" | sed 's/^origin\///')
            
            if [[ "$CLEAN_BRANCH" =~ ^(Feature|Fix|Update|Hotfix)- ]]; then
              # æª¢æŸ¥é€™å€‹åˆ†æ”¯æ˜¯å¦å·²ç¶“ merge é€² dev
              if git merge-base --is-ancestor "$branch" origin/dev 2>/dev/null; then
                BRANCHES="$BRANCHES- $CLEAN_BRANCH"$'\n'
              fi
            fi
          done

          # å¦‚æœæ²’æœ‰å‰¯åˆ†æ”¯ï¼Œå°±åˆ—å‡ºä¸»è¦åˆ†æ”¯
          if [ -z "$BRANCHES" ]; then
            BRANCHES="- dev"$'\n'"- qa"
          else
            # ç§»é™¤æœ«å°¾çš„æ–°è¡Œ
            BRANCHES=$(echo "$BRANCHES" | sed '$ s/.$//')
          fi

          echo "branches<<EOF" >> $GITHUB_OUTPUT
          echo "$BRANCHES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 7: ç”¢ç”Ÿ PR æè¿°
      - name: Generate PR description
        id: pr_body
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
          BRANCHES: ${{ steps.branches_list.outputs.branches }}
        run: |
          VERSION_NUM=$(echo "$NEW_VERSION" | sed 's/\.//g')
          cat > /tmp/pr_body.txt << 'EOF'
          Dev v$VERSION_NUM merge:

          $BRANCHES
          EOF

          BODY=$(cat /tmp/pr_body.txt)
          BODY="${BODY//\$VERSION_NUM/$VERSION_NUM}"
          BODY="${BODY//\$BRANCHES/$BRANCHES}"

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 8: å»ºç«‹ Release PR
      - name: Create Release PR to main
        id: create_pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.ACTIONS_PAT }}
          commit-message: 'chore(release): v${{ steps.check_version.outputs.final_version }}'
          title: 'Dev v${{ steps.check_version.outputs.final_version }}'
          body: ${{ steps.pr_body.outputs.body }}
          branch: ${{ steps.check_version.outputs.branch_name }}
          base: main
          labels: 'release,automation'
          assignees: ${{ github.actor }}
          draft: false
          delete-branch: false

      - name: Notify workflow completion
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
          FINAL_VERSION: ${{ steps.check_version.outputs.final_version }}
          OLD_VERSION: ${{ steps.version.outputs.current }}
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Release workflow completed successfully!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Version Information:"
          echo "   Previous version:  v$OLD_VERSION"
          echo "   Calculated version: v$INITIAL_VERSION"

          if [ "$INITIAL_VERSION" != "$FINAL_VERSION" ]; then
            echo "   âš ï¸  Conflict detected! Branch dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') already exists"
            echo "   ğŸ”„ Auto-incremented to: v$FINAL_VERSION"
          else
            echo "   Final version:     v$FINAL_VERSION"
          fi

          echo ""
          echo "ğŸ“Œ Branch & PR Details:"
          echo "   Branch name: $BRANCH_NAME"
          echo "   PR number:   #$PR_NUMBER"
          echo "   Base branch: main"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
