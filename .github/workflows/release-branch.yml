name: Create Release Branch

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version type to bump'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write
  pull-requests: write

jobs:
  create-release-branch:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.next }}
      release_branch: ${{ steps.create_branch.outputs.branch_name }}
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ACTIONS_PAT }}
          ref: dev
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # æ­¥é©Ÿ 1: æƒææ‰€æœ‰ä¾†æºï¼ˆåˆ†æ”¯ + å·²åˆä½µ PRï¼‰ä¾†åµæ¸¬æœ€æ–°ç‰ˆæœ¬è™Ÿ
      - name: Detect latest version from branches and merged PRs
        id: version
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
        run: |
          # Fetch all remote branches with prune to remove stale references
          git fetch origin --all --prune 2>&1 | head -10

          echo "ğŸ“‹ Scanning existing dev-v* branches..."
          git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V | tail -5 || echo "No dev-v branches found"
          echo ""

          echo "ğŸ“‹ Scanning merged PRs to main for version history..."
          # ä½¿ç”¨ gh CLI å–å¾—å·²åˆä½µåˆ° main çš„ PR æ¨™é¡Œ
          MERGED_VERSIONS=$(gh pr list --state merged --base main --limit 50 --json title --jq '.[].title' 2>/dev/null | grep -oP 'Dev v\K[0-9]+' | sort -V | tail -5 || echo "")
          echo "Found merged versions: $MERGED_VERSIONS"
          echo ""

          # æƒææ‰€æœ‰ dev-vXXX åˆ†æ”¯ï¼Œæå–ç‰ˆæœ¬è™Ÿ
          LATEST_VERSION="0.0.0"
          LATEST_SOURCE="initial"

          # å‡½æ•¸ï¼šå°‡ç‰ˆæœ¬è™Ÿå­—ä¸²è½‰æ›ç‚º X.Y.Z æ ¼å¼
          parse_version() {
            local VERSION_NUM=$1
            local NUM_LEN=${#VERSION_NUM}
            local MAJOR=0 MINOR=0 PATCH=0
            
            if [ $NUM_LEN -eq 1 ]; then
              PATCH=$VERSION_NUM
            elif [ $NUM_LEN -eq 2 ]; then
              MINOR=${VERSION_NUM:0:1}
              PATCH=${VERSION_NUM:1:1}
            elif [ $NUM_LEN -ge 3 ]; then
              # è™•ç† 3 ä½æ•¸ä»¥ä¸Šï¼šå–å‰ä¸‰ä½
              MAJOR=${VERSION_NUM:0:1}
              MINOR=${VERSION_NUM:1:1}
              PATCH=${VERSION_NUM:2:1}
            fi
            echo "$MAJOR.$MINOR.$PATCH"
          }

          # å‡½æ•¸ï¼šæ¯”è¼ƒå…©å€‹ç‰ˆæœ¬ï¼Œå›å‚³ 1 å¦‚æœ $1 > $2
          version_gt() {
            local V1_MAJOR=$(echo $1 | cut -d. -f1)
            local V1_MINOR=$(echo $1 | cut -d. -f2)
            local V1_PATCH=$(echo $1 | cut -d. -f3)
            local V2_MAJOR=$(echo $2 | cut -d. -f1)
            local V2_MINOR=$(echo $2 | cut -d. -f2)
            local V2_PATCH=$(echo $2 | cut -d. -f3)
            
            if [ $V1_MAJOR -gt $V2_MAJOR ]; then return 0; fi
            if [ $V1_MAJOR -eq $V2_MAJOR ] && [ $V1_MINOR -gt $V2_MINOR ]; then return 0; fi
            if [ $V1_MAJOR -eq $V2_MAJOR ] && [ $V1_MINOR -eq $V2_MINOR ] && [ $V1_PATCH -gt $V2_PATCH ]; then return 0; fi
            return 1
          }

          # ä¾†æº 1: æƒæç¾æœ‰çš„é ç«¯åˆ†æ”¯
          echo "ğŸ” Source 1: Scanning remote branches..."
          for branch in $(git branch -r --format='%(refname:short)' | grep '^origin/dev-v' | sort -V 2>/dev/null || echo ""); do
            VERSION_NUM=$(echo "$branch" | sed 's/^origin\/dev-v//')
            if [[ $VERSION_NUM =~ ^[0-9]+$ ]]; then
              DETECTED=$(parse_version $VERSION_NUM)
              if version_gt "$DETECTED" "$LATEST_VERSION"; then
                LATEST_VERSION=$DETECTED
                LATEST_SOURCE="branch: $branch"
              fi
            fi
          done

          # ä¾†æº 2: æƒæå·²åˆä½µåˆ° main çš„ PR æ¨™é¡Œï¼ˆæŠ“å–æ­·å²ç‰ˆæœ¬ï¼‰
          echo "ğŸ” Source 2: Scanning merged PR titles..."
          for VERSION_NUM in $(gh pr list --state merged --base main --limit 100 --json title --jq '.[].title' 2>/dev/null | grep -oP 'Dev v\K[0-9]+' || echo ""); do
            if [[ $VERSION_NUM =~ ^[0-9]+$ ]]; then
              DETECTED=$(parse_version $VERSION_NUM)
              if version_gt "$DETECTED" "$LATEST_VERSION"; then
                LATEST_VERSION=$DETECTED
                LATEST_SOURCE="merged PR: Dev v$VERSION_NUM"
              fi
            fi
          done

          # ä¾†æº 3: æƒæ package.json ä¸­çš„ç‰ˆæœ¬ï¼ˆä½œç‚ºå‚™ç”¨ï¼‰
          echo "ğŸ” Source 3: Checking package.json..."
          if [ -f package.json ]; then
            PKG_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
            if version_gt "$PKG_VERSION" "$LATEST_VERSION"; then
              LATEST_VERSION=$PKG_VERSION
              LATEST_SOURCE="package.json"
            fi
          fi

          echo ""
          echo "ğŸ¯ Latest version detected: v$LATEST_VERSION (from $LATEST_SOURCE)"
          echo "current=$LATEST_VERSION" >> $GITHUB_OUTPUT

          # è¨ˆç®—åˆå§‹æ–°ç‰ˆæœ¬
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
          case "${{ github.event.inputs.version_type }}" in
            major)
              NEW_VERSION="$((MAJOR+1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR+1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              ;;
          esac

          echo "next=$NEW_VERSION" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 2: æª¢æŸ¥è¨ˆç®—çš„ç‰ˆæœ¬åˆ†æ”¯æ˜¯å¦å­˜åœ¨ï¼ˆå¤šé‡ä¾†æºé©—è­‰ï¼‰ï¼Œå¦‚æœå­˜åœ¨å‰‡è‡ªå‹•é€²ä½
      - name: Check and auto-increment version if conflict
        id: check_version
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
        run: |
          CURRENT_VERSION=$INITIAL_VERSION
          ATTEMPT=0
          MAX_ATTEMPTS=10

          echo "ğŸ” Checking if branch dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') exists..."

          # å‡½æ•¸ï¼šæª¢æŸ¥åˆ†æ”¯æˆ–ç›¸é—œ PR æ˜¯å¦å·²å­˜åœ¨
          branch_or_pr_exists() {
            local BRANCH_NAME=$1
            local VERSION_NUM=$(echo "$BRANCH_NAME" | sed 's/dev-v//')
            
            # æª¢æŸ¥ 1: é ç«¯åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            if git ls-remote --heads origin "$BRANCH_NAME" 2>/dev/null | grep -q "$BRANCH_NAME"; then
              echo "remote-branch"
              return 0
            fi
            
            # æª¢æŸ¥ 2: æ˜¯å¦æœ‰ open çš„ PR ä½¿ç”¨é€™å€‹ç‰ˆæœ¬
            # ä½¿ç”¨ || true ç¢ºä¿ gh æŒ‡ä»¤å¤±æ•—æ™‚ä¸æœƒä¸­æ–·è…³æœ¬
            OPEN_PRS=$(gh pr list --state open --json title --jq '.[].title' 2>/dev/null || echo "")
            if echo "$OPEN_PRS" | grep -q "Dev v$VERSION_NUM" 2>/dev/null; then
              echo "open-pr"
              return 0
            fi
            
            # æª¢æŸ¥ 3: æ˜¯å¦æœ‰å·²åˆä½µçš„ PR ä½¿ç”¨é€™å€‹ç‰ˆæœ¬
            MERGED_PRS=$(gh pr list --state merged --base main --limit 100 --json title --jq '.[].title' 2>/dev/null || echo "")
            if echo "$MERGED_PRS" | grep -q "Dev v$VERSION_NUM" 2>/dev/null; then
              echo "merged-pr"
              return 0
            fi
            
            echo "not-found"
            return 0
          }

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            BRANCH_SUFFIX=$(echo "$CURRENT_VERSION" | sed 's/\.//g')
            BRANCH_NAME="dev-v${BRANCH_SUFFIX}"
            
            # å¤šé‡ä¾†æºæª¢æŸ¥
            EXISTENCE_CHECK=$(branch_or_pr_exists "$BRANCH_NAME")
            
            if [ "$EXISTENCE_CHECK" = "not-found" ]; then
              echo "âœ… Branch $BRANCH_NAME is available (no conflicts found)!"
              echo "final_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
              echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
              break
            else
              echo "âš ï¸ Conflict detected for $BRANCH_NAME (source: $EXISTENCE_CHECK), auto-incrementing..."
              
              # é€²ä½ patch ç‰ˆæœ¬
              IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
              CURRENT_VERSION="$MAJOR.$MINOR.$((PATCH+1))"
              
              ATTEMPT=$((ATTEMPT+1))
            fi
          done

          if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
            echo "âŒ ERROR: Could not find an available version after $MAX_ATTEMPTS attempts!"
            exit 1
          fi

          if [ "$CURRENT_VERSION" != "$INITIAL_VERSION" ]; then
            echo ""
            echo "ğŸ”„ Version auto-incremented:"
            echo "   Initial: v$INITIAL_VERSION â†’ dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') (conflict)"
            echo "   Final:   v$CURRENT_VERSION â†’ dev-v$(echo $CURRENT_VERSION | sed 's/\.//g') (using this)"
          fi

      # æ­¥é©Ÿ 3: æ›´æ–°ç‰ˆæœ¬åœ¨ package.json
      - name: Update version in package.json
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          if [ -f package.json ]; then
            node -e "const pkg = require('./package.json'); pkg.version = '$NEW_VERSION'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
            echo "âœ… Updated package.json to v$NEW_VERSION"
          else
            echo "âš ï¸ package.json not found"
          fi

      # æ­¥é©Ÿ 4: æ›´æ–° CHANGELOG
      - name: Update CHANGELOG
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          TODAY=$(date +%Y-%m-%d)
          cat > /tmp/new_entry.txt << EOF
          ## [$NEW_VERSION] - $TODAY

          ### Added
          - New features

          ### Fixed
          - Bug fixes

          ### Changed
          - Changes

          EOF

          if [ -f CHANGELOG.md ]; then
            cat /tmp/new_entry.txt CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
            echo "âœ… Updated CHANGELOG.md"
          else
            cat /tmp/new_entry.txt > CHANGELOG.md
            echo "âœ… Created CHANGELOG.md"
          fi

      # æ­¥é©Ÿ 5: å»ºç«‹å¸¶ç‰ˆæœ¬è™Ÿçš„åˆ†æ”¯
      - name: Create release branch
        id: create_branch
        env:
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
        run: |
          echo "ğŸŒ¿ Creating branch: $BRANCH_NAME"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # å»ºç«‹æ–°åˆ†æ”¯
          git checkout -b "$BRANCH_NAME"
          echo "âœ… Created local branch: $BRANCH_NAME"

          # åª add å­˜åœ¨çš„æª”æ¡ˆ
          git add package.json 2>/dev/null || true
          git add CHANGELOG.md 2>/dev/null || true

          # æª¢æŸ¥æ˜¯å¦æœ‰æª”æ¡ˆè¢« stage
          if git diff --cached --quiet; then
            echo "âš ï¸ No changes to commit, creating empty commit"
            git commit --allow-empty -m "chore(release): v$NEW_VERSION"
          else
            echo "âœ… Committing changes..."
            git commit -m "chore(release): v$NEW_VERSION"
          fi

          # Push åˆ°é ç«¯
          echo "Pushing to remote..."
          if git push -u origin "$BRANCH_NAME" 2>&1; then
            echo "âœ… Successfully pushed to origin/$BRANCH_NAME"
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to push"
            exit 1
          fi

      # æ­¥é©Ÿ 6: åˆ†æè‡ªä¸Šæ¬¡ release ä»¥ä¾†çš„æ‰€æœ‰ commitï¼Œæå–ç›¸é—œåˆ†æ”¯
      - name: Get all related branches from commits
        id: branches_list
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
        run: |
          echo "ğŸ” Analyzing commits since last release..."

          # æ–¹æ³• 1: æ‰¾å‡º main å’Œ dev çš„å·®ç•°ï¼Œå–å¾—æ‰€æœ‰ merge commit
          echo "ğŸ“‹ Method 1: Analyzing merge commits between main and dev..."

          # å–å¾— dev ç›¸å°æ–¼ main çš„æ‰€æœ‰ merge commit
          MERGE_COMMITS=$(git log origin/main..origin/dev --merges --oneline --reverse 2>/dev/null || echo "")

          if [ -n "$MERGE_COMMITS" ]; then
            echo "Found merge commits:"
            echo "$MERGE_COMMITS"
            echo ""
          fi

          # å¾ merge commit è¨Šæ¯ä¸­æå–åˆ†æ”¯åç¨±å’Œ PR è™Ÿç¢¼
          # æ ¼å¼: "Merge pull request #XX from user/branch-name"
          BRANCHES_FROM_MERGES=$(echo "$MERGE_COMMITS" \
            | grep -oP "Merge pull request #\d+ from [^/]+/\K\S+" \
            | awk '!seen[$0]++' \
            | grep -E "^(Feature|Fix|Update|Hotfix)-" \
            | sed 's/^/- /' || echo "")

          # æ–¹æ³• 2: ä½¿ç”¨ GitHub API å–å¾—åˆä½µåˆ° dev çš„ PRï¼ˆè£œå……æ–¹æ³• 1ï¼‰
          echo "ğŸ“‹ Method 2: Fetching merged PRs from GitHub API..."

          # å–å¾—æ‰€æœ‰åˆä½µåˆ° dev çš„ PRï¼ˆä¸é™æ™‚é–“ï¼‰
          API_PRS=$(gh pr list \
            --state merged \
            --base dev \
            --limit 100 \
            --json number,headRefName,mergedAt \
            --jq '.[] | "\(.headRefName) #\(.number)"' \
            2>/dev/null || echo "")

          # éæ¿¾å‡º Feature/Fix/Update/Hotfix é–‹é ­çš„åˆ†æ”¯ï¼Œä¸¦æ’é™¤å·²ç¶“åœ¨ main ä¸Šçš„
          BRANCHES_FROM_API=""
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              BRANCH_NAME=$(echo "$line" | cut -d' ' -f1)
              PR_NUM=$(echo "$line" | cut -d'#' -f2)
              
              # æª¢æŸ¥æ˜¯ Feature/Fix/Update/Hotfix é–‹é ­
              if [[ "$BRANCH_NAME" =~ ^(Feature|Fix|Update|Hotfix)- ]]; then
                # æª¢æŸ¥é€™å€‹ PR çš„ commit æ˜¯å¦é‚„æ²’åœ¨ main ä¸Š
                # é€éæª¢æŸ¥åˆ†æ”¯åç¨±æ˜¯å¦å‡ºç¾åœ¨ merge commits ä¸­
                if echo "$MERGE_COMMITS" | grep -q "$BRANCH_NAME" 2>/dev/null; then
                  BRANCHES_FROM_API="$BRANCHES_FROM_API- $BRANCH_NAME #$PR_NUM"$'\n'
                fi
              fi
            fi
          done <<< "$API_PRS"

          # åˆä½µå…©ç¨®æ–¹æ³•çš„çµæœï¼Œå»é‡
          ALL_BRANCHES=""

          if [ -n "$BRANCHES_FROM_API" ]; then
            ALL_BRANCHES="$BRANCHES_FROM_API"
          elif [ -n "$BRANCHES_FROM_MERGES" ]; then
            ALL_BRANCHES="$BRANCHES_FROM_MERGES"
          fi

          # å»é™¤é‡è¤‡ï¼ˆä¿æŒé †åºï¼‰
          if [ -n "$ALL_BRANCHES" ]; then
            ALL_BRANCHES=$(echo "$ALL_BRANCHES" | grep -v '^$' | awk '!seen[$0]++')
          fi

          # å¦‚æœé‚„æ˜¯ç©ºçš„ï¼Œé¡¯ç¤ºæç¤ºè¨Šæ¯
          if [ -z "$ALL_BRANCHES" ]; then
            ALL_BRANCHES="- (è‡ªä¸Šæ¬¡ release ä»¥ä¾†ç„¡æ–°çš„åŠŸèƒ½åˆ†æ”¯åˆä½µ)"
          fi

          echo ""
          echo "âœ… Final branch list:"
          echo "$ALL_BRANCHES"

          echo "branches<<EOF" >> $GITHUB_OUTPUT
          echo "$ALL_BRANCHES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 7: ç”¢ç”Ÿ PR æè¿°
      - name: Generate PR description
        id: pr_body
        env:
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
          BRANCHES: ${{ steps.branches_list.outputs.branches }}
        run: |
          VERSION_NUM=$(echo "$NEW_VERSION" | sed 's/\.//g')
          cat > /tmp/pr_body.txt << 'EOF'
          Dev v$VERSION_NUM merge:

          $BRANCHES
          EOF

          BODY=$(cat /tmp/pr_body.txt)
          BODY="${BODY//\$VERSION_NUM/$VERSION_NUM}"
          BODY="${BODY//\$BRANCHES/$BRANCHES}"

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # æ­¥é©Ÿ 8: å»ºç«‹ Release PRï¼ˆä½¿ç”¨ gh CLIï¼‰
      - name: Create Release PR to main
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.ACTIONS_PAT }}
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          NEW_VERSION: ${{ steps.check_version.outputs.final_version }}
          PR_BODY: ${{ steps.pr_body.outputs.body }}
        run: |
          VERSION_NUM=$(echo "$NEW_VERSION" | sed 's/\.//g')

          echo "ğŸ“ Creating PR: $BRANCH_NAME -> main"

          # å…ˆç¢ºä¿ label å­˜åœ¨ï¼ˆå¦‚æœä¸å­˜åœ¨å°±å»ºç«‹ï¼‰
          echo "ğŸ·ï¸ Ensuring labels exist..."
          gh label create "release" --color "0E8A16" --description "Release PR" 2>/dev/null || echo "Label 'release' already exists"
          gh label create "automation" --color "1D76DB" --description "Automated PR" 2>/dev/null || echo "Label 'automation' already exists"

          # å»ºç«‹ PR
          PR_URL=$(gh pr create \
            --base main \
            --head "$BRANCH_NAME" \
            --title "Dev v$VERSION_NUM" \
            --body "$PR_BODY" \
            --label "release,automation" \
            --assignee "${{ github.actor }}" \
            2>&1) || true

          if [[ "$PR_URL" == *"already exists"* ]]; then
            echo "âš ï¸ PR already exists for $BRANCH_NAME"
            PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --base main --json number --jq '.[0].number')
          elif [[ "$PR_URL" == http* ]]; then
            echo "âœ… PR created: $PR_URL"
            PR_NUMBER=$(echo "$PR_URL" | grep -oP '\d+$')
          else
            echo "âŒ Failed to create PR: $PR_URL"
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "âœ… PR #$PR_NUMBER created successfully!"

      - name: Notify workflow completion
        env:
          INITIAL_VERSION: ${{ steps.version.outputs.next }}
          FINAL_VERSION: ${{ steps.check_version.outputs.final_version }}
          OLD_VERSION: ${{ steps.version.outputs.current }}
          BRANCH_NAME: ${{ steps.check_version.outputs.branch_name }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
        run: |
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Release workflow completed successfully!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ğŸ“Š Version Information:"
          echo "   Previous version:  v$OLD_VERSION"
          echo "   Calculated version: v$INITIAL_VERSION"

          if [ "$INITIAL_VERSION" != "$FINAL_VERSION" ]; then
            echo "   âš ï¸  Conflict detected! Branch dev-v$(echo $INITIAL_VERSION | sed 's/\.//g') already exists"
            echo "   ğŸ”„ Auto-incremented to: v$FINAL_VERSION"
          else
            echo "   Final version:     v$FINAL_VERSION"
          fi

          echo ""
          echo "ğŸ“Œ Branch & PR Details:"
          echo "   Branch name: $BRANCH_NAME"
          echo "   PR number:   #$PR_NUMBER"
          echo "   Base branch: main"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
